<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>开发过程采坑记录 - Sorzen</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/Sorzen"><span>Github</span></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d"><span>掘金</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">开发过程采坑记录</h1><ul class="meta"><li><i class="icon icon-author"></i>Sorzen</li><li><i class="icon icon-clock"></i>5 Minutes</li><li><i class="icon icon-calendar"></i>May 3, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近开发中遇到一些不太常遇到的问题，心血来潮记录一下他们产生的原因，有些问题找了很久才发现问题所在，也给需要的人一些帮助。<br><a id="more"></a></p>
<h2 id="问题1：Form表单提交bug"><a href="#问题1：Form表单提交bug" class="headerlink" title="问题1：Form表单提交bug"></a>问题1：Form表单提交bug</h2><p>当form表单中只含有一个input输入框时，并且输入框获取焦点然后点击enter时会触发form表单的默认提交事件（input为textarea时不会触发），产生的后果是页面刷新，但是当页面包含两个以上input输入框时不会触发form表单的默认提交。</p>
<h3 id="问题定位过程"><a href="#问题定位过程" class="headerlink" title="问题定位过程"></a>问题定位过程</h3><p>当发现这个现象时想到的产生这个现象原因可能是组件自身遗留问题，因为开发采用的是iview，是在使用Tag+Input组件时发现这个bug，因为Input组件使用的enter事件是经过封装之后暴露出来的事件，因此怀疑是组件自身问题，于是使用原生事件去替代，还是会触发表单默认提交动作，后经查阅才发现是form表单中有单个input框造成的原因，之后便对症下药寻找解决之法。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="一、避免form中有单个input输入框"><a href="#一、避免form中有单个input输入框" class="headerlink" title="一、避免form中有单个input输入框"></a>一、避免form中有单个input输入框</h4><p>  当页面中无法避免使用单个input输入框时，再添加一个input框并使用v-show=”false”使其隐藏。<br>  这个方法虽然可以很简便解决问题，但是页面中无故多出一些元素，不仅代码不美观而且使代码可读性大大降低，因此不太推荐使用此方法。</p>
<h4 id="二、禁用input的enter事件"><a href="#二、禁用input的enter事件" class="headerlink" title="二、禁用input的enter事件"></a>二、禁用input的enter事件</h4><p>为防止input在form表单中无故被提交，因此最好的办法就是禁止🚫enter事件，在页面加载时即mounted()添加form表单阻止事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 阻止表单的默认提交事件，当页面只有一个input并且focus后点击会触发form表单的默认</span><br><span class="line">  document.getElementsByTagName(&apos;form&apos;)[0].addEventListener(&apos;keypress&apos;, (event) =&gt; &#123;</span><br><span class="line">    if (event.keyCode === 13 &amp;&amp; event.target.tagName !== &apos;TEXTAREA&apos;) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="三、禁用form中所有的enter事件"><a href="#三、禁用form中所有的enter事件" class="headerlink" title="三、禁用form中所有的enter事件"></a>三、禁用form中所有的enter事件</h4><p>利用事件委托原理，直接在父级元素上添加事件，即可使页面中所有input元素禁用enter事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form @keypress.enter.native=&quot;$event.preventDefault()”&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>缺点：<br>虽然这个方法可以解决遇到的问题，但是当页面中某些input需要enter事件，会容易形成误伤，因此推荐第二种方法进行分类解决，可以避免误伤的情况。</p>
<h2 id="问题2：vue中父组件对子组件设置v-if属性导致watch不起作用"><a href="#问题2：vue中父组件对子组件设置v-if属性导致watch不起作用" class="headerlink" title="问题2：vue中父组件对子组件设置v-if属性导致watch不起作用"></a>问题2：vue中父组件对子组件设置v-if属性导致watch不起作用</h2><h3 id="一、比如-："><a href="#一、比如-：" class="headerlink" title="一、比如 ："></a>一、比如 ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;add-roles  v-if=&quot;flag&quot;  :id=&quot;current_id&quot; &gt;&lt;/add-roles&gt;</span><br></pre></td></tr></table></figure>
<p>有个函数把flag 设置为true 子组件显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">look_role(id) &#123;</span><br><span class="line">  this.flag = true;</span><br><span class="line">  this.current_id =id;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props:[&quot;id&quot;],</span><br><span class="line">watch:&#123;</span><br><span class="line"> &apos;id&apos;: function(newVal,oldVal)&#123;</span><br><span class="line">    console.log(&quot;sdfsadf&quot;,newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>你会发现根本监听不到 id 的变化<br>这是因为v-if会影响子组件的生命周期导致watch不起作用</p>
<h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><p>我们可以从这两者区别来探讨原因：<br>v-if 是’真正的’条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建.</p>
<p>v-if 也是惰性的,如果在初始渲染时条件为假,那么什么都不做，直到条件第一次为真的时候才会开始渲染条件块,<br>相比之下,v-show就简单得多，不管初始条件是什么,元素总会被渲染,并且只是简单的基于css进行切换.</p>
<p>一般来说,v-if 有更高的切换开销,而 v-show 有更高的初始渲染开销.因此,如果需要非常频繁的切换,那么使用v-show好一点;如果在<br>运行时条件不太可能改变,则使用v-if 好点.</p>
<p>因此当v-if=”false”时，页面并没有渲染此DOM元素，当设置为true时才开始渲染，因此当v-if=’true’时父组件开始渲染子组件，因此子组件不能及时watch父组件传来的值的变化。<br>当使用v-show时只是在css样式上的显示和隐藏，而DOM元素一直存在于页面中，子组件可以一直监测父组件传递来的值的变化。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/踩坑-开发中遇到的bug/">踩坑,开发中遇到的bug</a><span class="tag-list-count">1</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjucwgsgx000haszvjd9nty1x" data-title="开发过程采坑记录" data-url="http://yoursite.com/2018/05/03/开发过程采坑/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/09/26/使用Web Worker开启浏览器多线程/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/03/03/js设计模式/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/Sorzen" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d" title="掘金" target="_blank"><i class="icon icon-juejin"></i></a></li><li><a href="https://segmentfault.com/" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Sorzen<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>