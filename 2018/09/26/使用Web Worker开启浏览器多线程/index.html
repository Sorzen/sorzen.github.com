<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>使用Web Worker开启浏览器多线程 - Sorzen</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/Sorzen"><span>Github</span></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d"><span>掘金</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">使用Web Worker开启浏览器多线程</h1><ul class="meta"><li><i class="icon icon-author"></i>Sorzen</li><li><i class="icon icon-clock"></i>9 Minutes</li><li><i class="icon icon-calendar"></i>September 26, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>javascript是单线程模型，如果要处理一些密集型任务时可能会拖慢主进程的执行（如页面UI卡顿），是否可以使javascript像其他语言使用多线程方式运行，一部分运行在UI线程下，另一部分运行一个独立线程（如只进行某些复杂运算）。</p>
<p>Web Worker作用就是为javascript提供一个创建多线程环境，但是这是浏览器的功能，实际和javascript语言本身几乎没什么关系，浏览器可以提供多个引擎实例，各自运行在自身的线程上，这样就可以在不同的线程上运行不同的程序。在worker内部是无法访问主程序的任何资源，这意味着你不能访问它的任何全局变量，也不能访问页面的DOM或者其他资源，这是一个完全独立的线程。<br><a id="more"></a></p>
<h3 id="Web-Worker-有以下几个使用注意点。"><a href="#Web-Worker-有以下几个使用注意点。" class="headerlink" title="Web Worker 有以下几个使用注意点。"></a>Web Worker 有以下几个使用注意点。</h3><p>（1）同源限制<br>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）DOM 限制<br>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>
<p>（3）通信联系<br>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（4）脚本限制<br>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（5）文件限制<br>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Worker之间以及他们主程序之间，不会共享任何作用域或资源，它是通过一个基本的事件消息机制相互联系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*实例化一个worker*/</span><br><span class="line">var worker = new Worker(&apos;URL&apos;); // 这个文件应该指向一个javascript文件，这个文件就是worker线程要执行的任务，但是worker不能读取本地文件，所以这个文件需要来自网络。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 监听函数，监听&apos;message&apos;事件</span><br><span class="line">worker.addEventListener(&apos;message&apos;, function(event) &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*向worker传递信息*/</span><br><span class="line">worker.postMessge(&apos;hello worker&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*从worker接收信息,主线程接收子线程传来的消息*/</span><br><span class="line">worker.onmessage = function(event)&#123;</span><br><span class="line">    console.log(event.data)     //&apos;hello worker&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在worker中加载额外的javascri脚本</span><br><span class="line">importScripts(&quot;url&quot;); // 脚本记载是同步的，会阻塞余下worker的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 终止主线程</span><br><span class="line">worker.terminate(); // 突然终止线程不会给他任何机会完成他的工作或者清理任何资源，这就类似于直接关闭浏览器标签页。</span><br></pre></td></tr></table></figure>
<p>具体使用详情可参考：<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker 使用教程</a></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Web Worker通常应用于哪些方面？</p>
<ul>
<li>处理密集型数学计算</li>
<li>大数据集排序</li>
<li>数据处理（压缩、音频分析、图像处理等）</li>
<li>高流量网络通信</li>
</ul>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>当对一个文件需要生成MD5时，一般都是将文件传给后台然后将结果传递给前台进行使用，是否可以在前台直接生成然后使用呢？答案是肯定的，但是在未使用Web Worker时可能会影响页面响应，导致较大的文件不太使用此方法，但是我们可以用这个想法尝试使用一下Web Worker。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;</span><br><span class="line">const file = files[0]; // 获取文件对象 </span><br><span class="line"></span><br><span class="line">const fileReader = new FileReader();</span><br><span class="line">const worker = new Worker(&apos;readFileAsBuffer.js&apos;) // 开启worker线</span><br><span class="line"></span><br><span class="line">/*fileReader读取完成，传递给worker*/</span><br><span class="line">fileReader.onload = function(e)&#123;</span><br><span class="line">    worker.postMessage(&#123;</span><br><span class="line">        operation:&apos;sendArrayBuffer&apos;,</span><br><span class="line">        input:e.target.result,</span><br><span class="line">        threshold:0.8,</span><br><span class="line">        finish:true</span><br><span class="line">    &#125;,[e.target.result])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileReader.onerror = function()&#123;</span><br><span class="line">    console.log(&apos;文件读取失败，请重试&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*worker线程计算MD5完成并返回结果*/</span><br><span class="line">worker.onmessage = function(event)&#123;</span><br><span class="line">    /*读取完成，获取md5*/</span><br><span class="line">    const md5 = event.data;</span><br><span class="line">    file.md5 = md5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*使用FileReader读取文件*/</span><br><span class="line">fileReader.readAsArrayBuffer(blobSlice.call(file,0,file.size));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-----woker文件部分,readFileAsBuffer.js-------</span><br><span class="line"></span><br><span class="line">/*在worker线程中，如果需要引入别的文件，要使用importScripts*/</span><br><span class="line">importScripts(&apos;@/node_modules/spark-md5/spark-md5.js&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const spark = new SparkMD5.ArrayBuffer();</span><br><span class="line">const saveArrayBuffer = [];</span><br><span class="line">const start = false;</span><br><span class="line">const finish = false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*接收到主线程发来的文件*/</span><br><span class="line">onmessage = function(event)&#123;</span><br><span class="line">    spark.append(event.data.input);</span><br><span class="line">    const md5 = spark.end();</span><br><span class="line">    postMessage(md5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前对于Web Worker用得还比较少，也希望以后能看到全面且深度利用Web Worker的有意思的开源框架或项目。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebWorker-浏览器多线程/">WebWorker 浏览器多线程</a><span class="tag-list-count">1</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjucwf8ng00066uzv9nrzmgws" data-title="使用Web Worker开启浏览器多线程" data-url="http://yoursite.com/2018/09/26/使用Web Worker开启浏览器多线程/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/10/24/前端监控/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/05/03/开发过程采坑/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/Sorzen" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d" title="掘金" target="_blank"><i class="icon icon-juejin"></i></a></li><li><a href="https://segmentfault.com/" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Sorzen<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>