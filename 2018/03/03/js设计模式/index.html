<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>JS设计模式 - Sorzen</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/Sorzen"><span>Github</span></a></li><li><a href="/about/resume.html"><span>关于作者</span></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d"><span>掘金</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">JS设计模式</h1><ul class="meta"><li><i class="icon icon-author"></i>Sorzen</li><li><i class="icon icon-clock"></i>16 Minutes</li><li><i class="icon icon-calendar"></i>March 3, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解前端常见设计模式，使代码更加系统化与规范化<br><a id="more"></a></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂方法模式是一种实现”工厂”概念的面向对象设计模式，它是最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p>
<h3 id="工厂模式要点"><a href="#工厂模式要点" class="headerlink" title="工厂模式要点"></a>工厂模式要点</h3><ul>
<li>工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。</li>
<li>工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>优点：可以解决创建多个相似对象的问题</li>
<li>缺点：未解决对象识别的问题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">   	<span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">    person.name = name;</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.sex = sex;</span><br><span class="line">    person.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Factory(<span class="string">'Tom'</span>,<span class="string">'10'</span>,<span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">let</span> jerry = <span class="keyword">new</span> Factory(<span class="string">'Jerry'</span>,<span class="string">'20'</span>,<span class="string">'female'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="复杂工厂模式"><a href="#复杂工厂模式" class="headerlink" title="复杂工厂模式"></a>复杂工厂模式</h2><p>复杂工厂模式与简单工厂模式对比，主要区别就是它不是另外使用一个对象或者类来创建实例,而是使用一个子类。工厂是一个将其成员对象的实例化推迟到子类中进行的类，子类可以重写父类接口方法以便创建时指定独自的对象类型 父类只对创建过程中的一般性问题进行处理，子类继承，但子类之间相互独立，具体业务再各自实现 父类变为抽象类，不能被实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Factory,</span><br><span class="line">    createFactory: function()&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'父类抽象类无法直接调用，需要子类重写'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">sub,sup</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义空函数</span></span><br><span class="line">    <span class="keyword">let</span> F= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//空函数原型为父类原型</span></span><br><span class="line">    F.prototype = sup.prototype;</span><br><span class="line">    <span class="comment">//实例化空函数传递给子类原型</span></span><br><span class="line">    sub.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="comment">//使子类构造器指向自身</span></span><br><span class="line">    sub.prototype.constructor = sub;</span><br><span class="line">    <span class="comment">//保存父类原型</span></span><br><span class="line">    sub.sup = sup.prototyp;</span><br><span class="line">    <span class="comment">//检测父类原型为父类自身</span></span><br><span class="line">    <span class="keyword">if</span>(sup.prototype.constructor === <span class="built_in">Object</span>.prototype.constructor)&#123;</span><br><span class="line">        sup.prototype.constructor = sup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Factory.call(<span class="keyword">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(Person,Factory);</span><br><span class="line"></span><br><span class="line">Person.prototype.createFactory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.name)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Tom'</span>: <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">age</span>: <span class="number">10</span>, <span class="attr">sex</span>: <span class="string">'male'</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Jerry'</span>: <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">sex</span>: <span class="string">'female'</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tom = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">let</span> tom1 = Tom.createFactory();</span><br></pre></td></tr></table></figure>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它定义对象间一对多的依赖关系，当一个对象发生变化时，所有依赖于它的对象都将得到通知。</p>
<h3 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事件管理器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>)</span>&#123;     <span class="comment">// 事件管理器</span></span><br><span class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;;         <span class="comment">// 存储事件处理的函数</span></span><br><span class="line">&#125;</span><br><span class="line">EventTarget.prototype = &#123;     </span><br><span class="line">    <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line">    addHandler: function(type, handler)&#123; <span class="comment">// 添加事件的方法 type:事件类型 handler:事件的回调函数</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[type] == <span class="string">"undefined"</span>)&#123; <span class="comment">// 创建事件类型不存在</span></span><br><span class="line">              <span class="keyword">this</span>.handlers[type] = []; <span class="comment">// 创建数组用于存放事件</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.handlers[type].push(handler);</span><br><span class="line">     &#125;,</span><br><span class="line">    fire: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; <span class="comment">// 执行handles对象里的某个类型的每一个方法</span></span><br><span class="line">         <span class="keyword">if</span> (!event.target)&#123;</span><br><span class="line">             event.target = <span class="keyword">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">             <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[event.type];</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                 handlers[i](event);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">type, handler</span>)</span>&#123;  <span class="comment">// 删除函数的方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[type];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (handlers[i] === handler)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             handlers.splice(i, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>观察者模式可以用于模块间通讯，订阅用户的事件、状态，触发执行相应的逻辑处理。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点<br>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他操作。</p>
</li>
<li><p>缺点<br>增加了系统复杂度</p>
</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<ul>
<li>优点<br>可以避免很多if语句，可以将需要的条件封装成类<br>通过类的形式声明对象，可以很方便的进行拓展</li>
</ul>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS-设计模式/">JS,设计模式</a><span class="tag-list-count">1</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjucxpn2u000321zvospbkinm" data-title="JS设计模式" data-url="http://yoursite.com/2018/03/03/js设计模式/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/05/03/开发过程采坑/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/01/30/electron-vue实践笔记/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/Sorzen" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d" title="掘金" target="_blank"><i class="icon icon-juejin"></i></a></li><li><a href="https://segmentfault.com/" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Sorzen<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>