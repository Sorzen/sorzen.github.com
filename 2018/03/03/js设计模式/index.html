<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Sorzen,owengengshaozhen@live.com"><title>JS设计模式 · Sorzen</title><meta name="description" content="工厂模式工厂方法模式是一种实现”工厂”概念的面向对象设计模式，它是最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。
工厂模式要点
工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。
工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。"><meta name="keywords" content="HTML,CSS,JavaScript,Vue"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Sorzen</a></h3><div class="description"><p>记录个人学习感受和学习笔记！  --Sorzen</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2941002937/profile?rightmod=1&amp;wvr=6&amp;mod=personnumber&amp;is_all=1"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/Sorzen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about/resume.html">简历</a></li><li><a href="/archives">归档</a></li><li><a href="https://github.com/Sorzen">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JS设计模式</a></h3></div><div class="post-content"><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂方法模式是一种实现”工厂”概念的面向对象设计模式，它是最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p>
<h3 id="工厂模式要点"><a href="#工厂模式要点" class="headerlink" title="工厂模式要点"></a>工厂模式要点</h3><ul>
<li>工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。</li>
<li>工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>优点：可以解决创建多个相似对象的问题</li>
<li>缺点：未解决对象识别的问题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name,age,sex</span>)</span>&#123;</div><div class="line">   	<span class="keyword">let</span> person = &#123;&#125;;</div><div class="line">    person.name = name;</div><div class="line">    person.age = age;</div><div class="line">    person.sex = sex;</div><div class="line">    person.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Factory(<span class="string">'Tom'</span>,<span class="string">'10'</span>,<span class="string">'male'</span>);</div><div class="line"><span class="keyword">let</span> jerry = <span class="keyword">new</span> Factory(<span class="string">'Jerry'</span>,<span class="string">'20'</span>,<span class="string">'female'</span>);</div></pre></td></tr></table></figure>
<h2 id="复杂工厂模式"><a href="#复杂工厂模式" class="headerlink" title="复杂工厂模式"></a>复杂工厂模式</h2><p>复杂工厂模式与简单工厂模式对比，主要区别就是它不是另外使用一个对象或者类来创建实例,而是使用一个子类。工厂是一个将其成员对象的实例化推迟到子类中进行的类，子类可以重写父类接口方法以便创建时指定独自的对象类型 父类只对创建过程中的一般性问题进行处理，子类继承，但子类之间相互独立，具体业务再各自实现 父类变为抽象类，不能被实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//工厂构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Factory.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Factory,</div><div class="line">    <span class="attr">createFactory</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'父类抽象类无法直接调用，需要子类重写'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//原型继承</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">sub,sup</span>)</span>&#123;</div><div class="line">    <span class="comment">//定义空函数</span></div><div class="line">    <span class="keyword">let</span> F= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    <span class="comment">//空函数原型为父类原型</span></div><div class="line">    F.prototype = sup.prototype;</div><div class="line">    <span class="comment">//实例化空函数传递给子类原型</span></div><div class="line">    sub.prototype = <span class="keyword">new</span> F();</div><div class="line">    <span class="comment">//使子类构造器指向自身</span></div><div class="line">    sub.prototype.constructor = sub;</div><div class="line">    <span class="comment">//保存父类原型</span></div><div class="line">    sub.sup = sup.prototyp;</div><div class="line">    <span class="comment">//检测父类原型为父类自身</span></div><div class="line">    <span class="keyword">if</span>(sup.prototype.constructor === <span class="built_in">Object</span>.prototype.constructor)&#123;</div><div class="line">        sup.prototype.constructor = sup;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    Factory.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">extend(Person,Factory);</div><div class="line"></div><div class="line">Person.prototype.createFactory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.name)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'Tom'</span>: <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">age</span>: <span class="number">10</span>, <span class="attr">sex</span>: <span class="string">'male'</span>&#125;;</div><div class="line">        <span class="keyword">case</span> <span class="string">'Jerry'</span>: <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">sex</span>: <span class="string">'female'</span>&#125;;</div><div class="line">        <span class="keyword">default</span> : <span class="keyword">return</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> Tom = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>);</div><div class="line"><span class="keyword">let</span> tom1 = Tom.createFactory();</div></pre></td></tr></table></figure>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它定义对象间一对多的依赖关系，当一个对象发生变化时，所有依赖于它的对象都将得到通知。</p>
<h3 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建事件管理器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>)</span>&#123;     <span class="comment">// 事件管理器</span></div><div class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;;         <span class="comment">// 存储事件处理的函数</span></div><div class="line">&#125;</div><div class="line">EventTarget.prototype = &#123;     </div><div class="line">    <span class="attr">constructor</span>: EventTarget,</div><div class="line">    <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type, handler</span>)</span>&#123; <span class="comment">// 添加事件的方法 type:事件类型 handler:事件的回调函数</span></div><div class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[type] == <span class="string">"undefined"</span>)&#123; <span class="comment">// 创建事件类型不存在</span></div><div class="line">              <span class="keyword">this</span>.handlers[type] = []; <span class="comment">// 创建数组用于存放事件</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">this</span>.handlers[type].push(handler);</div><div class="line">     &#125;,</div><div class="line">    <span class="attr">fire</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; <span class="comment">// 执行handles对象里的某个类型的每一个方法</span></div><div class="line">         <span class="keyword">if</span> (!event.target)&#123;</div><div class="line">             event.target = <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">             <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[event.type];</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</div><div class="line">                 handlers[i](event);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;,</div><div class="line">     <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type, handler</span>)</span>&#123;  <span class="comment">// 删除函数的方法</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[type];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=handlers.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (handlers[i] === handler)&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             handlers.splice(i, <span class="number">1</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>观察者模式可以用于模块间通讯，订阅用户的事件、状态，触发执行相应的逻辑处理。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点<br>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他操作。</p>
</li>
<li><p>缺点<br>增加了系统复杂度</p>
</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<ul>
<li>优点<br>可以避免很多if语句，可以将需要的条件封装成类<br>通过类的形式声明对象，可以很方便的进行拓展</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-03</span><i class="fa fa-tag"></i><a href="/tags/JS-设计模式/" title="JS,设计模式" class="tag">JS,设计模式 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2018/03/03/js设计模式/,Sorzen,JS设计模式,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2018/01/30/electron-vue实践笔记/" title="electron-vue实践" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>