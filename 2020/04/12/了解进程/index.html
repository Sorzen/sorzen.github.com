<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>了解进程 - Sorzen</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/Sorzen"><span>Github</span></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d"><span>掘金</span></a></li><li><a href="/about/resume.html"><span>关于作者</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/images/postBackground.jpg"><div class="post-title"><h1 class="title">了解进程</h1><ul class="meta"><li><i class="icon icon-author"></i>Sorzen</li><li><i class="icon icon-clock"></i>8 Minutes</li><li><i class="icon icon-calendar"></i>April 12, 2020</li></ul></div></div><div class="article-content" style="max-width:800px;"><h2 id="什么是线程与进程"><a href="#什么是线程与进程" class="headerlink" title="什么是线程与进程"></a>什么是线程与进程</h2><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p>
<p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。<br><a id="more"></a></p>
<p>node遵循的是单线程单进程的模式，node的单线程是指js的引擎只有一个实例，且在nodejs的主线程中执行，同时node以事件驱动的方式处理IO等异步操作。node的单线程模式，只维持一个主线程，大大减少了线程间切换的开销。</p>
<p>但是node的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。</p>
<p>此外，node的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡型。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>面对单进程单线程对多核利用不足的问题，因此需要启动多进程。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。Node提供了child_process模块，也提供了child_process.fork()函数供我们实现进程的复制。</p>
<p>我们来简单模拟一下如创建worker.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="built_in">Math</span>.round((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">1000</span>), <span class="string">'127.0.0.1'</span>)</span><br><span class="line">通过node worker.js启动它，将会真听到<span class="number">1000</span><span class="number">-2000</span>的随机端口开启。</span><br><span class="line"></span><br><span class="line">我们再创建master.js,并通过node master.js启动它：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line">cpus.forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fork(<span class="string">'./worker.js'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码会根据当前机器上CPU数量复制出对应的Node进程数，在Linux下可以通过ps aux | grep worker.js</p>
<p><img src="/2020/04/12/了解进程/psWorker.png" alt="psWorker"></p>
<p>这相当于主从模式，进程主要分为两种：主进程和工作进程，主要用于分布式架构中用于并行处理业务的模式，举杯较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度和管理工作进程。工作进程负责具体的业务处理。<br><img src="/2020/04/12/了解进程/主从进程.png" alt="主从进程"></p>
<p>通过fork()复制的进程都是一个独立的进程，尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然切记fork()进程是昂贵的。Node通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在主从模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间通信。对于child_process模块，创建好了子进程，然后父子进程之间通信是十分容易的。<br>主线程与工作线程之间通过onmessage()和postmessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据，message事件实现收听子进程发来的数据。通过消息传递内容，而不是共享或者直接操作相关资源，这是比较清凉和无依赖的做法。</p>
<p>eg:<br>// parent.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="keyword">const</span> sub = cp.fork(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/sub.js`</span>)</span><br><span class="line"></span><br><span class="line">sub.on(<span class="string">'message'</span>, (mes) =&gt; &#123; <span class="comment">// 主线程接收子线程发来的消息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Parent get message: <span class="subst">$&#123;mes&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sub.send(&#123;<span class="attr">hello</span>: <span class="string">'world'</span>&#125;) <span class="comment">// 主线程向子线程发送消息</span></span><br><span class="line"><span class="comment">// sub.js</span></span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'message'</span>, (mes) =&gt; &#123; <span class="comment">// 子线程接收父线程发来的消息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Child get message: <span class="subst">$&#123;mes&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.send(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;) <span class="comment">// 子线程发送消息给父线程</span></span><br></pre></td></tr></table></figure>
<p>通过fork()或者其他API创建子进程之后，为了实现父子进程间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道父子进程之间才能通过message和send()传递消息。</p>
<h2 id="进程间通信原理"><a href="#进程间通信原理" class="headerlink" title="进程间通信原理"></a>进程间通信原理</h2><p>IPC即进程间通信，进程间通信的目的就是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术。具体实现是由libuv提供。表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。<br><img src="/2020/04/12/了解进程/IPC.png" alt="IPC"></p>
<p>父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量告诉子进程这个IPC通道的文件描述符。子进程启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。<br><img src="/2020/04/12/了解进程/创建IPC管道.png" alt="创建IPC管道"></p>
<p>建立连接之后的父子进程就可以自由的通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网络socket的行为比较类似是双向通信。不同的是它们在系统内核中就完成了进程间的通信，而不用经过实际的网络层，非常高效。<br>在Node中，IPC通道被抽象为stream对象，在调用send()时发送数据，接受到的信息会通过message事件触发给应用层。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过创建子进程、进程间通信的IPC通道实现、句柄在进程间的发送和还原、端口共用等细节。通过这些基础技术，用child_process模块在单机上搭建Node集群是件相对容易的事情。因此在多核CPU的环境下，可以让Node进程能够充分利用资源。</p>
</div><div class="article-meta" style="max-width:800px;"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-child-process-进程/">Node child_process 进程</a><span class="tag-list-count">1</span></li></ul></div></div><div class="article-comment" style="max-width:800px;"><div class="ds-thread" id="ds-thread" data-thread-key="ck8x67k4400005fs605u859z0" data-title="了解进程" data-url="http://yoursite.com/2020/04/12/了解进程/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2020/04/12/Buffer的理解/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2020/04/12/表格的表头及多列冻结/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/Sorzen" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.im/user/57b6e96ba34131005f86ba5d" title="掘金" target="_blank"><i class="icon icon-juejin"></i></a></li><li><a href="https://segmentfault.com/" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 Sorzen<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script><script src="/live2d-widget/autoload.js"></script></body></html>